
# 자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식
- https://fe-developers.kakaoent.com/2022/220519-garbage-collection/

자바스크립트는 어떤 방식으로 메모리를 해제하는걸까 (v8 엔진 기준)

## 메모리 생존 주기

### 1. 할당한다.
- 원시타입은 스택 영역에 참조 타입은 힙 영역에 저장됩니다. 해당 주소값은 스택 영역에 저장됩니다.
- 또한 변수 식별자는 스택 영역 상의 실행 컨텍스트 렉시컬 환경에 저장됩니다.

### 2. 사용한다.
```
console.log(a); // 10
console.log(b[0]); // 1
```
### 3. 필요 없으면 해제한다.
수동으로 쓸모없는 메모리 영역을 해제할 수 없기에 가비지 컬렉터(GC)를 통해 메모리 영역을 클리어합니다. 어떻게 판단, 동작할까요

## 메모리 구조(v8 엔진)
프로그램을 실행하면 메모리의 Resident Set이라는 빈 공간이 할당됩니다. 
자바스크립트는 싱글쓰레드이기에 스택 메모리는 하나만 가집니다. 
스택은 함수 호출 끝난후 자동으로 정리되지만 힙메모리는 그렇지 않기 때문에 해제 되지 않으면 메모리 누수가 발생합니다.

### 힙
- space 종류: New space, Old space, Large Object space, 코드 space, 셀 space, 속성 space, 맵 space
- 가비지 컬렉션이 일어나는 부분은 New space와 Old space이므로 두 파트만 알아봅니다.
	- New space(Young generation): 새로 만들어진 Object가 저장됩니다.
	- Old space(Old generation): New space에서 마이너 가비지 컬렉션이 2번 발생할 동안 살아남은 객체들이 저장됩니다. 이 영역은 두 개로 나눌 수 있습니다.
		- Pointer space: 다른 객체를 참조하는 객체 (다른 객체에 대한 포인터를 가진 객체)
		- Data space: 문자열, 실수 등의 데이터만을 가진 객체(primitive?)

## 가비지 컬렉터(GC)
- v8은 힙 영역을 generations라고 불리는 New, Old space로 나눴습니다
- New space는 2개의 semi space로 나뉩니다.
### 객체 할당, GC 동작 방식
1. 객체는 처음에 New space의 첫번째 semi space에 할당됩니다.
2. 만약 GC로부터 한번 생존한다면 다른 semi space로 이동합니다.
3. 그리고 생존한 객체들이 또 한번 GC로부터 생존하면 Old space로 이동합니다.

- 가비지 컬렉션은 New space에서의 Minor GC와 Old space에서의 Major GC로 각각 다른 방식으로 동작합니다. (위 설명 방식은 Minor GC 방식을 의미한다는 말인듯한)

### The Generational Hypothesis
- 대부분의 경우 새로운 객체가 오래된 객체보다 쓸모없어질 가능성이 높다는 것입니다.
- 오래된 객체가 쓸모없어질 가능성이 낮은데 GC가 모든 객체를 매번 검사하는 것은 비효율적입니다.
- 마이너 GC는 객체들의 생명주기가 짧은 New space에서 빠르게 가비지 컬렉션을 하고, 메이저 GC는 메모리 사이즈가 큰 Old space에서 가비지 컬렉션을 합니다.

### 1. 마이너 GC(Scavenger)
- 마이너 GC에서 살아남은 객체들은 항상 새로운 곳으로 대피(evacuation) 합니다. 
이 대피 과정에서 언제나 1개의 semi space는 비어있습니다. 비어있는 영역은 To space, 객체들이 머무르는 영역은 From space라 부릅니다.
From space에서 To space로 이동할 때 살아남은 객체들은 연속적인(붙어있는) 메모리로 이동합니다. 연속적으로 이동함으로 인해 메모리 단편화(ex) 윈도우 조각모음?)를 방지합니다. 그리고 객체는 새로운 메모리 주소값으로 포인터가 갱신됩니다.
- Mark & Sweep 알고리즘으로 살아남을 객체를 정합니다.

- From space에서 To space로 생존한 객체들의 대피가 완료되면, From space에 남아있는 더 이상 쓸모없는 객체들을 버립니다. 마지막으로 From space와 To space의 역할을 서로 바꿔줍니다.

- 새로운 객체가 할당된다고 가정해 봅시다. 먼저, From space의 다음 빈 주소에 할당됩니다. 그리고 새로운 객체는 생존하여 To space로 대피합니다. 하지만 기존에 한 번 생존했던 4개의 객체는 또 한 번 생존하면 To space가 아닌 Old space로 이동됩니다.

### 2. 메이저 GC
- Mark-Sweep-Compact 알고리즘과 Tri-color 알고리즘을 사용합니다.
- 3단계에 걸쳐서 동작합니다.
- 마킹
	- 어떤 객체들이 가비지 컬렉션 대상인지 알아내기 위한 단계입니다. Roots라는 실행 스택과 전역 객체를 담고 있는 객체의 set부터 시작해서 객체들을 dfs로 순회하며 Tri-color(white, gray, black)로 마킹합니다.
		- white: GC가 아직 탐색하지 못한 상태
		- gray: 탐색은 했으나 해당 객체가 참조하고 있는 객체가 있는지 확인을 안한 상태
		- black: 해당 객체가 참조하고 있는 객체까지 확인을 한 상태
		1. 모든 객체는 흰색으로 마킹
		2. root 객체를 회색으로 마킹 후 덱(스택 + 큐)에 push_front
		3. 덱에서 pop_front하여 객체를 꺼냄
		4. 꺼낸 객체는 검은색으로 마킹
		5. 꺼낸 객체가 참조하는 객체들은(인접 객체) 회색으로 마킹 후 덱에 push_front
			5-1. 흰색 -> 회색인 경우에만 덱에 push_front
			5-2. 여러 객체가 참조하는 객체인 경우 이미 회색 or 검은색일 수 있음
			5-3. 회색 or 검은색인 경우 탐색 과정에서 방문된 객체이므로 덱에 push_front하지 않음.
		6. 3~5번 과정을 반복하여 덱이 빌때까지 반복
		7. 최종적으로 모든 객체들이 흰색, 검은색
- 스위핑
	- 여전히 흰색으로 마킹된 객체들의 메모리 주소를 free-list라고 부르는 자료구조에 추가합니다. 이제 이 주소들의 메모리 공간은 사용 가능하여 새로운 객체가 저장 가능합니다.
- 압축
	- 메모리 단편화가 심한 페이지들을 재배치하여 추가적인 메모리를 확보합니다.

## Orinoco
- 위에서 배운 전통적인 마이너 GC와 메이저 GC의 가비지 컬렉션이 수행할 때 프로그램이 멈추게 됩니다. 이를 stop-the-world라고 합니다. 이 시간이 길어질수록 페이지가 느려지거나 렌더링이 지연되어 사용자들은 UX 경험이 좋지 못할 것입니다. 이에 Orinoco 프로젝트를 통해 GC는 발전해 왔습니다. 최신의 GC에는 어떤 기술들이 추가되었는지 간략하게 알아봅시다.
### Parallel
- 기존에는 메인 쓰레드 혼자 하던 일을 헬퍼 쓰레드들과 균등하게 나누어 일을 합니다. 쓰레드 간의 동기화를 처리해야 해서 오버헤드는 생기지만 stop-the-world 시간이 크게 감소합니다.

### Incremental
- 메인 쓰레드가 적은 양의 작업을 간헐적으로 처리합니다. 메인 스레드에서 가비지 컬렉션에 소요하는 시간이 분산되어, 좋은 UX를 제공할 수 있습니다.

### Concurrent
- 메인 쓰레드는 더 이상 가비지 컬렉션을 하지 않고, 헬퍼 쓰레드들이 수행합니다. 기술적으로 구현하기는 어렵지만, 메인 쓰레드의 stop-the-wolrd 시간이 전혀 없다는 큰 장점이 있습니다.

### Idle-time GC
- 개발자는 GC에 직접 접근할 수 없습니다. 하지만 v8은 크롬과 같은 embedder에게 가비지 컬렉션을 유발할 수 있는 메커니즘을 제공합니다. 크롬은 프로그램이 쉬는 free나 idle time을 알 수 있습니다. 예를 들면, 1초에 60프레임을 제공하는 크롬은 1프레임을 렌더링 하기 위해 약 16ms(1s / 60)가 소모됩니다. 만약 애니메이션 프레임 렌더링 작업이 16ms 보다 빨리 끝나면, 크롬은 다음 프레임 작업 전까지 가비지 컬렉션을 유발합니다.

### QA
- 메모리 누수 문제 중 과남용한 클로져 사용 후 해제하지 않는 케이스일듯 하나 어떻게 발견할 수 있을지
- New space에서 객체가 왜 두번 생존하는 Rule로 정하였는지, New space -> Old space로 이동하기까지 체감 duration은 어느정도일까??

